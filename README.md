# ft_transcendence backend

## database and pgadmin

Our backend app needs a postgreSQL database to work and pgAdmin will help us to manage this database.

To launch them, we can use this ```docker-compose.yml``` file :

```
version: '3'
services:
    postgres:
        container_name: postgres
        image: 'postgres:latest'
        environment:
            POSTGRES_USER: pg1
            POSTGRES_PASSWORD: pg2
            POSTGRES_DB: pg3
        ports:
            - '5432:5432'
        restart: always
    pgadmin:
        container_name: pgadmin4_container
        image: dpage/pgadmin4
        restart: always
        environment:
            PGADMIN_DEFAULT_EMAIL: admin@admin.com
            PGADMIN_DEFAULT_PASSWORD: root
        ports:
            - "5050:80"
```
In the same directory, Use the command :

```
docker-compose down && docker-compose up --build
```
In another terminal, find the ID of our postgres container with ```docker ps``` and its IP address with this command, replacing XXX with the container ID:
```
docker inspect XXX | grep IPAddress
```

Then go to localhost:5050, log in with email admin@admin.com and password root

Right click on Servers -> Register -> Server.

Choose any name then go to Connection tab.

Host name: IP address of postgres container

Port: 5432

Username: pg1

Password: pg2

Click Save.

Once our app will be launched, we will be able to add, modify or delete elements in our tables.

## Backend application

To launch the app :
```
git clone git@github.com:hmesnard/ft_transcendence.git
cd ft_transcendence/backend
npm install
nest start --watch
```

localhost:3000 should display a Hello World.

Now, if you reload pgAdmin, you should be able to access tables through Servers -> The name you have chosen -> Databases -> pg3 -> Schemas -> public -> Tables.

Then see their content by right clicking on them -> View/Edit Data -> All Rows.

You can edit elements as well. Click on save to take changes into consideration.

## Authentication flow

To authenticate our users, Oauth 2.0 (with 42) and second factor authentication (with Google Authenticator) has been implemented, with a Jwt token to keep the connection.

### 42 Oauth

Send GET request to ```/auth/42```

If you are not logged to 42 intra, it will direct you to the log in page.

Once logged in, the backend is redirected to ```/auth/42/return``` and returns the user's informations in the response and a Jwt token in a cookie.

This token can be sent, in a cookie or as a bearer token, to access all the routes if the user did not turn on second factor authentication, or only ```/auth/tfa``` otherwise.

### Second factor authentication with Google Authenticator

(TFA stands for two factor authentication)

Any user has the option to improve the security of their account by turning on second factor authentication.

First of all, we need to generate a secret that will be used to make one-time passwords.

To do so, send a POST request to ```/user/tfa/secret```. It will generate a new secret for the user and return it in a QR code in the response.

This QR code needs to be scanned in the Google Authenticator app to store the secret on your phone.

Then, to turn on second factor authentication for this user, you need to send a POST request to ```/user/tfa/turn-on``` with a tfaCode generated by Google Authenticator in the request body.

Once turned on, this double authentication will be needed to access routes.

To authenticate, send a POST request to ```/auth/tfa``` with the Jwt token returned earlier by ```/auth/42/return``` and with a tfaCode generated by Google Authentication in the request body. It will return again the user's informations in the response but a new Jwt token in a cookie that will be able to access all routes.
